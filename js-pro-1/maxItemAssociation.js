/*
Задача про список рекомендаций maxItemAssociation

Цель:
Написать алгоритм для нахождения максимального списка рекомендаций.

Описание/Пошаговая инструкция выполнения домашнего задания:
Это задание является достаточно сложным, однако может быть интересно тем, кто хочет попробовать свои силы с реальными примерами из реальных собеседований.
Если вы хотите попробовать решить менее сложную задачу, внизу можно найти задание 2. Решение любого из заданий достаточно для зачета этого ДЗ.
Задание 1.
Написать функцию maxItemAssociation(), получающую исторические данные покупок пользователей и возвращающую максимальный список рекомендаций.
Входные данные - массив исторических покупок пользователей [["a", "b"], ["a", "c"], ["d", "e"]]. То есть пользователь 1 купил "a" и "b". Пользователь 2 купил продукты "a", "c". Пользователь 3 купил продукты "d", "e".
Надо найти максимальную группу рекомендаций. Группа рекомендаций - это продукты, которые был куплены другими пользователями при условии, если они пересекаются с исходным списком.
Если количество рекомендаций в группах одинаковое - вернуть первую группу, из отсортированных в лексикографическом порядке.
Решение:
Группа рекомендаций 1 - ["a", "b", "c"]. Покупка "a" содержится в списке 2, поэтому весь список 2 может быть добавлен в рекомендации.
Группа рекомендаций 2 - ["d", "e"].
Ответ: ["a", "b", "c"].
Пример 2:
Входные данные: [
["q", "w", 'a'],
["a", "b"],
["a", "c"],
["q", "e"],
["q", "r"],
]
Ответ ["a", "b", "c", "e", "q", "r", "w"] - это максимальная по пересечениям группа. Можно видеть, что первый массив пересекается со всеми остальными, и потому результат является всем множеством значений.

 */

function maxItemAssociation(allRecs) {
    function onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
    }

    // рекоммендации
    let maxRec = [];

    for (let i = 0; i < allRecs.length; i++) {
        // текущий список покупок
        let curRec = [...allRecs[i]];

        for (let j = 0; j < allRecs.length; j++) {
            if (i !== j) {
                // список покупок другого польз.
                const sibRec = allRecs[j];
                // проверяем на вхождение покупки текущего в список другого польз.
                const sameRecElement = curRec.find((rec) => sibRec.includes(rec));
                if (sameRecElement) {
                    // если есть, то объединяем списки, делаем уникальные значения и сортируем
                    curRec = [...sibRec, ...curRec].filter(onlyUnique).sort();
                }
            }
        }
        // если последующая рекоммендация больше, то обновляем ее
        if (curRec.length > maxRec.length) {
            maxRec = curRec;
        }
    }
    return maxRec;
}

console.log(
    "test 1",
    maxItemAssociation([
        ["a", "b"],
        ["a", "c"],
        ["d", "e"]
    ])
);
console.log(
    "test 2",
    maxItemAssociation([
        ["q", "w", "a"],
        ["a", "b"],
        ["a", "c"],
        ["q", "e"],
        ["q", "r"]
    ])
);
